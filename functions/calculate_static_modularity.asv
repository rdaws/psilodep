function [Q_norm, FC, TC] = calculate_static_modularity(imaging_volume, atlas_volume, nP)

% 1 - load atlas and subject runs
% 2 - Extract timecourses
% 3 - Run modularity estimation, for each run
% 4 - Run null modularity, for each run
% 5 - Normalise modularity

%%

    % Number of permutations
    if (~exist('nP', 'var'))
        nP = 100;
    end
    


%% 1 Wrangle atlas

    % Find number of ROIs
    nRoi=numel(unique(atlas_volume(atlas_volume>0)));
    % Reshape atlas to 2D
    atlas_volume=reshape(convert.label2Dummy(atlas_volume)>0, [],  nRoi); 

%% 2 Load imaging_data

    [imaging_volume,G]=load.vol(imaging_volume); % load run
    V=reshape(V, prod(G.d(1:3)), G.d(4)); % Reshape to 2D     


%% 2 Extract mean timecourses for each atlas region


    TC = V'*atlas_volume ./ sum(atlas_volume); % Extract mean timecourse, per roi


%% 3 define FC matrix with Pearson correlation and filtering

    % Define functional connectivity with Pearson correlation
    FC = corr(TC);

    % Remove negative correlations
    FC = FC .* (FC > 0);

    % Fisher transform r to z-scores
    FC=c3nl_fisher(c3nl_symAdj(FC, 'mean'), 'r2z');

    % Replace inf's on diagonal with 1
    FC(logical(eye(size(FC))))=1;

    % Replace NaN with 0
    FC(isnan(FC))=0;


%% Estimate Modularity (Q) for the real and shuffled FC matrices nP times

    Q = zeros(nP, 1);
    Q_null = zeros(nP, 1);

    % Run Q estimation on real and shuffled networks nP times
    for ii = 1:nP
        [~,Q(ii)]=community_louvain(FC,1);
        [~,Q_null(ii)]=community_louvain(randmio_und(FC,1),1);
    end


%% Normalise Q

    % Divide the max real Q value by the mean of the shuffled Q values
    Q_norm = max(Q) / mean(Q_null);



end
function calculate_dynamic_modularity(imaging_volume, atlas_volume)
%                                 _---~~(~~-_.
%                               _{        )   )
% ██████  ███████ ██████      ,   ) -~~- ( ,-' )_
% ██   ██ ██      ██   ██    (  `-,_..`., )-- '_,)
% ██████  █████   ██   ██   ( ` _)  (  -~( -_ `,  }
% ██   ██ ██      ██   ██   (_-  _  ~_-~~~~`,  ,' )
% ██   ██ ███████ ██████      `~ -^(    __;-,((()))
% Richard E. Daws  JUN2020           ~~~~ {_ -_(())
%                                          `\  }
%                                            { }   
% Psilodep :- Calculate dynamic modularity (Q)
% 
% Requires 
%    third_party folder and subfolders to be in path 
%
%
%   Args:
%       imagine_volume - 4D matrix of fMRI imaging data
%       atlas_volume   - 3D matrix of unique values denoting Regions of
%                        Interest(ROI)
%       nP             - Number of permutations to run when estimating
%                        modularity
% 
% Adapted from Karolina Finc et al 2020, Nat Comms. 
%
%

%% Parameters

W=15; % nTRs in a window
gamma = 1;
omega = 1;
nRep = 100;


%% 1 Wrangle atlas

    % Find number of ROIs
    nRoi=numel(unique(atlas_volume(atlas_volume>0)));
    % Reshape atlas to 2D
    atlas_volume=reshape(convert.label2Dummy(atlas_volume)>0, [],  nRoi); 

%% 2 Wrangle imaging_data

    imaging_shape = size(imaging_volume);
    imaging_volume = reshape(imaging_volume, prod(imaging_shape(1:3)), imaging_shape(4)); % Reshape to 2D   


%% 3 Define sliding window indices

    % define sliding window  
    IX=false(size(imaging_volume,2),1); IX(1:W)=1; % Define and expand window
    IX=cell2mat(arrayfun(@(x) circshift(IX, x), [0:sum(IX):size(IX,1)-(sum(IX))], 'uni',0));
    % Number of windows
    nWin=size(IX,2);
    
%% Calculate FC matrix for each window

    % Pairwise mean timecourse FC for each window
    FC=zeros(nRoi,nRoi,size(IX,2));
    for win = 1:nWin
        FC(:,:,win) = corr(imaging_volume(:,IX(:,win))'*atlas_volume ./ sum(atlas_volume)); % pairwise FC
    end

%% Wrangle FC matrices

    % Retain pos. weightings
    FC = FC .* (FC > 0);

    % Fisher transform r to z-score
    FC=c3nl_fisher(c3nl_symAdj(FC, 'mean'), 'r2z'); 
    FC(logical(repmat(eye(size(FC,1)),1,1,nWin)))=1; % Correct inf's from fisher on diagonal         
    FC(isnan(FC))=0; % Remove NaN's
    
    
    % Reset for the current run
    A = cell(1, nWin);
    B = spalloc(nRoi * nWin, nRoi * nWin,(nRoi + nWin) * nRoi* nWin);
    twomu = 0;
    
    %--- null model -------------------------------------------------------
    for win = 1 : nWin
        A{win} = FC(:,:,win); % extract FC for a window
        k = sum(A{win});                             % node degree
        twom = sum(k);                               % mean network degree
        twomu = twomu + twom;                        % increment
        indx = [1:nRoi] + (win-1)*nRoi;              % find indices
        B(indx,indx) = A{win} - gamma * [k'*k]/twom; % fill B matrix
    end
    twomu = twomu + 2*omega* nRoi*(nWin-1);
    
    B = B + omega/2*spdiags(ones(nRoi*nWin,2),[-nRoi, nRoi], nRoi*nWin, nRoi*nWin);
    B = B + omega*spdiags(ones(nRoi*nWin,2),[-2*nRoi, 2*nRoi], nRoi*nWin, nRoi*nWin);
    
    for rep = 1 : nRep
        [S,Qtmp] = genlouvain(B);
        Qtmp = Qtmp / twomu;
        S = reshape(S, nRoi, nWin);
    
        tmpl=Q.Properties.VariableNames{cell2mat(cellfun(@(x) contains(vols{ii}, x), Q.Properties.VariableNames,'Un',0))};
        
        Q.(tmpl)(rep) = Qtmp;
        modules.(tmpl)(:,:,rep) = S;
    end
















% Atlas
atlas_volume=load.vol(atlas); % Load atlas
nRoi=numel(unique(atlas_volume(atlas_volume>0))); % Find number of ROIs
atlas_volume=reshape(convert.label2Dummy(atlas_volume)>0, [],  nRoi); % Reshape atlas to 2D

% find runs belonging to a subject
tmp=c3nl_ls_subs(['ls -1v ' Rt '/rawData/*/*/*.nii'])';
vols=tmp(contains(tmp, SBJ));

% Output
Q = array2table(zeros(nRep, numel(C)), 'VariableNames', C);


% For each run
for ii = 1:numel(vols)
    
    disp(vols{ii})
    [image_volume,G]=load.vol(vols{ii}); % load run
    image_volume=reshape(image_volume, prod(G.d(1:3)), G.d(4)); % Reshape to 2D     
    
    % define window index  
    IX=false(size(image_volume,2),1); IX(1:W)=1; % Define and expand window
    IX=cell2mat(arrayfun(@(x) circshift(IX, x), [0:sum(IX):size(IX,1)-(sum(IX))], 'uni',0));
    nWin=size(IX,2);

    
    % Pairwise mean timecourse FC for each window
    FC=zeros(nRoi,nRoi,size(IX,2));
    for win = 1:nWin
        FC(:,:,win) = corr(image_volume(:,IX(:,win))'*atlas_volume ./ sum(atlas_volume)); % pairwise FC
    end
    FC = FC .* (FC > 0); % Retain pos. weightings
    FC=c3nl_fisher(c3nl_symAdj(FC, 'mean'), 'r2z'); % Unnecesary symmetary step, plus fisher transform
    FC(logical(repmat(eye(size(FC,1)),1,1,nWin)))=1; % Correct inf's from fisher on diagonal         
	FC(isnan(FC))=0; % Remove NaN's
    

    % Reset for the current run
    A = cell(1, nWin);
    B = spalloc(nRoi * nWin, nRoi * nWin,(nRoi + nWin) * nRoi* nWin);
    twomu = 0;

    %--- null model -------------------------------------------------------
    for win = 1 : nWin
        A{win} = FC(:,:,win); % extract FC for a window
        k = sum(A{win});                             % node degree
        twom = sum(k);                               % mean network degree
        twomu = twomu + twom;                        % increment
        indx = [1:nRoi] + (win-1)*nRoi;              % find indices
        B(indx,indx) = A{win} - gamma * [k'*k]/twom; % fill B matrix
    end
    twomu = twomu + 2*omega* nRoi*(nWin-1);

    B = B + omega/2*spdiags(ones(nRoi*nWin,2),[-nRoi, nRoi], nRoi*nWin, nRoi*nWin);
    B = B + omega*spdiags(ones(nRoi*nWin,2),[-2*nRoi, 2*nRoi], nRoi*nWin, nRoi*nWin);

    for rep = 1 : nRep
        [S,Qtmp] = genlouvain(B);
        Qtmp = Qtmp / twomu;
        S = reshape(S, nRoi, nWin);

        tmpl=Q.Properties.VariableNames{cell2mat(cellfun(@(x) contains(vols{ii}, x), Q.Properties.VariableNames,'Un',0))};
        
        Q.(tmpl)(rep) = Qtmp;
        modules.(tmpl)(:,:,rep) = S;
    end
   
end


%save
if ~exist([Rt '/modularity_dynamic/' SBJ],'dir')
mkdir([Rt '/modularity_dynamic/' SBJ])
end
save([Rt '/modularity_dynamic/' SBJ '/Q.mat'],'Q')
save([Rt '/modularity_dynamic/' SBJ '/modules.mat'],'modules') 